<?php

use \Drupal\node\NodeInterface;
use \Drupal\node\Entity\Node;
use Drupal\Core\Entity\EntityTypeManager;
use \Drupal\Core\Entity\RevisionLogInterface;
use Drupal\Core\Entity\EntityInterface;

/**
 * name comes from ini functionality: Copies the value from one field to another empty field.
 * A custom callback _my_module_copy_field_values allows Implementations of
 * hook_post_update_NAME that act as implementations of callback_batch_operation
 * across multiple HTTP requests and avoid PHP timeouts.
 *
 * @param array $sandbox
 * The batch operation sandbox.
 * @param string $bundle
 * The node bundle.
 * @param string $source_field
 * The source field name.
 * @param string $dest_field
 * The destination field.
 * @param int $nodes_per_batch
 * The amount of nodes to update at a given time.
 */
function _change_update_fields_copy_field_values(array &$sandbox, $bundle, $source_field, $dest_field, $nodes_per_batch = 20) {

  $storage = \Drupal::entityTypeManager()->getStorage('node');
  // Initialize some variables during the first pass through.
  // ->notExists($dest_field)  and ->exists($source_field) are only for copy ini case
  if (!isset($sandbox['total'])) {
    $query = $storage->getQuery()
      ->condition('type', $bundle)
      ->notExists($dest_field)
      ->exists($source_field)
//      ->range(0, 10)
//      ->sort('created', 'ASC')
      ->accessCheck(FALSE);

    $nids = $query->execute();

    $sandbox['total'] = count($nids);
    $sandbox['ids'] = array_chunk($nids, $nodes_per_batch);
    $sandbox['current'] = 0;
  }

  $nids = array_shift($sandbox['ids']);
  $nodes = $storage->loadMultiple($nids);

//  The code to programmatically copy field data in Drupal 8 isn’t the hard part.
// Assuming your source and destination field types are compatible,
// it’s just two quick lines:

// /* @var $node \Drupal\node\NodeInterface $node */
// $node->$dest_field = $node->$source_field;
// $node->save();

// It gets complicated when you need to do this on hundreds or thousands of entities.
// We don’t want to load, process, and save all those entities at once
// as that would likely bring our server down. We need to batch the operation.

  /* @var $node \Drupal\node\NodeInterface $node */
  foreach ($nodes as $node) {
    // This is main copy operation
    $node->$dest_field = $node->$source_field; // ini example: Programmatically copy field data

    $node->save();
    $sandbox['current']++;
  }
  $sandbox['#finished'] = min(($sandbox['current'] / $sandbox['total']), 1);
}

/**
 * name comes from functionality: just save all nodes for a bundle. Such case exists some time when we need Save to update field...
 * A custom callback _my_module_fields_save_bundle == _change_update_fields_save_bundle allows Implementations of
 * hook_post_update_NAME that act as implementations of callback_batch_operation
 * across multiple HTTP requests and avoid PHP timeouts.
 *
 * @param array $sandbox
 * The batch operation sandbox.
 * @param string $bundle
 * The node bundle.
 * @param int $nodes_per_batch
 * The amount of nodes to update at a given time.
 */
function _change_update_fields_save_bundle(array &$sandbox, $bundle, $nodes_per_batch = 20) {

  $storage = \Drupal::entityTypeManager()->getStorage('node');

  // as we need only ->save(operation)
  if (!isset($sandbox['total'])) {
    $query = $storage->getQuery()
      ->condition('type', $bundle)
      ->accessCheck(FALSE);

    $nids = $query->execute();

    $sandbox['total'] = count($nids);
    $sandbox['ids'] = array_chunk($nids, $nodes_per_batch);
    $sandbox['current'] = 0;
  }

  if ($sandbox['total'] == 0) {
    $sandbox['#finished'] = 1;
    return;
  }

  $nids = array_shift($sandbox['ids']);
  $nodes = $storage->loadMultiple($nids);

  // It gets complicated when you need to do this on hundreds or thousands of entities.
  // We don’t want to load, process, and save all those entities at once
  // as that would likely bring our server down. We need to batch the operation.

  /* @var $node \Drupal\node\NodeInterface $node */
  foreach ($nodes as $node) {
    $node->save();
    $sandbox['current']++;
  }

  $sandbox['#finished'] = min(($sandbox['current'] / $sandbox['total']), 1);
}

/**
 * name comes from functionality: publish all nodes from a bundle.
 * A custom callback _change_update_fields_publish_bundle allows Implementations of
 * hook_post_update_NAME that act as implementations of callback_batch_operation
 * across multiple HTTP requests and avoid PHP timeouts.
 *
 * @param array $sandbox
 * The batch operation sandbox.
 * @param string $bundle
 * The node bundle.
 * @param int $nodes_per_batch
 * The amount of nodes to update at a given time.
 */
function _change_update_fields_publish_bundle(array &$sandbox, $bundle, $nodes_per_batch = 20) {

  $storage = \Drupal::entityTypeManager()->getStorage('node');

  // as we need only ->save(operation) and we know what operation we want $node->setPublished(true); we will do it in line 168
  // From line 142 to 162 we divide/load nodes in batches, preparing nodes Nid's for operation in line 168
  if (!isset($sandbox['total'])) {
    $query = $storage->getQuery()
      ->condition('type', $bundle)
//      ->range(0, 2)
      ->sort('changed', 'DESC')
      ->accessCheck(FALSE);

    $nids = $query->execute();

    $sandbox['total'] = count($nids);
    $sandbox['ids'] = array_chunk($nids, $nodes_per_batch);
    $sandbox['current'] = 0;
  }

  if ($sandbox['total'] == 0) {
    $sandbox['#finished'] = 1;
    return;
  }

  $nids = array_shift($sandbox['ids']);
  $nodes = $storage->loadMultiple($nids);

  // It gets complicated when you need to do this on hundreds or thousands of entities.
  // We don’t want to load, process, and save all those entities at once
  // as that would likely bring our server down. We need to batch the operation.

  /* @var $node \Drupal\node\NodeInterface $node */
  foreach ($nodes as $node) {
//    $node->setPublished(true); // did not work if in draft as this node is under workflow
//    \Drupal::messenger()->addMessage("$node->id Node updated");

    $node->set('moderation_state', 'published');
    $node->set('langcode', 'en');
    if ($node instanceof RevisionLogInterface) {
      $node->setRevisionLogMessage('Set moderation state to Published.');
      $node->setRevisionUserId(\Drupal::currentUser()->id());
    }
    $node->save();
    $sandbox['current']++;
  }

  $sandbox['#finished'] = min(($sandbox['current'] / $sandbox['total']), 1);
}

/**
 * name comes from functionality: publish all nodes from a bundle.
 * A custom callback _change_update_fields_value_for_bundle allows Implementations of
 * hook_post_update_NAME that act as implementations of callback_batch_operation
 * across multiple HTTP requests and avoid PHP timeouts.
 *
 * @param array $sandbox
 * The batch operation sandbox.
 * @param string $bundle
 * The node bundle.
 * @param int $nodes_per_batch
 * The amount of nodes to update at a given time.
 */
function _change_update_fields_value_for_bundle(array &$sandbox, $bundle, $nodes_per_batch = 20) {

  $storage = \Drupal::entityTypeManager()->getStorage('node');

  // From line 204 to 224 we divide/load nodes in batches, preparing nodes Nid's for operation in line 218
  if (!isset($sandbox['total'])) {
    $query = $storage->getQuery()
      ->condition('type', $bundle)
      //      ->range(0, 2)
      ->sort('changed', 'DESC')
      ->accessCheck(FALSE);

    $nids = $query->execute();

    $sandbox['total'] = count($nids);
    $sandbox['ids'] = array_chunk($nids, $nodes_per_batch);
    $sandbox['current'] = 0;
  }

  if ($sandbox['total'] == 0) {
    $sandbox['#finished'] = 1;
    return;
  }

  $nids = array_shift($sandbox['ids']);
  $nodes = $storage->loadMultiple($nids);

  // It gets complicated when you need to do this on hundreds or thousands of entities.
  // We don’t want to load, process, and save all those entities at once
  // as that would likely bring our server down. We need to batch the operation.
   $curr_tid = 0;
   $current_field_geolocation = 0;
   $tid_1817_michigan_peninsula_lat_lng = ['lat'=> 45.9, 'lng' => -86.6];
   $tid_1076_central_greatlakes_lat_lng = ['lat'=> 44.2, 'lng' => -84.4];
   $tid_1808_bruce_peninsula_lat_lng = ['lat'=> 45.0, 'lng' => -81.3];
   $tid_1077_eastern_greatlakes_lat_lng = ['lat'=> 43.3, 'lng' => -78.1];
   $tid_1073_north_eastern_noam_lat_lng = ['lat'=> 43.6, 'lng' => -71.9];
   $tid_1829_eastern_ontario_lat_lng = ['lat'=> 45.1, 'lng' => -76.4];
   $tid_1058_fingers_lakes_lat_lng = ['lat'=> 42.7, 'lng' => -76.8];
   $tid_1074_georgian_bay_lat_lng = ['lat'=> 45.5, 'lng' => -81.1];
   $tid_1046_great_lakes_lat_lng = ['lat'=> 45.8, 'lng' => -83.9];
   $tid_1081_hudsons_bay_lat_lng = ['lat'=> 54.9, 'lng' => -82.8];
   $tid_1908_lake_winnipeg_lat_lng = ['lat'=> 53.5, 'lng' => -97.9];
   $tid_1075_manitoulin_island_lat_lng = ['lat'=> 45.7, 'lng' => -82.0];
   $tid_1078_north_great_lakes_lat_lng = ['lat'=> 47.4, 'lng' => -88.2];
   $tid_1082_ruperts_land_lat_lng = ['lat'=> 54.5, 'lng' => -91.0];
   $tid_1079_south_great_lakes_lat_lng = ['lat'=> 42.6, 'lng' => -80.5];
   $tid_1080_western_great_lake_lat_lng = ['lat'=> 46.2, 'lng' => -90.9];
   $tid_1069_western_ontario_lat_lng = ['lat'=> 43.1, 'lng' => -81.2];
   $tid_1071_other_lat_lng = ['lat'=> 42.7, 'lng' => -92.2];
   $tid_1072_unknown_lat_lng = ['lat'=> 48.7, 'lng' => -84.6];

  /* @var $node \Drupal\node\NodeInterface $node */
  foreach ($nodes as $node) {
    //    $node->setPublished(true); // did not work if in draft as this node is under workflow
    //    \Drupal::messenger()->addMessage("$node->id Node updated");
    $curr_tid = $node->get('field_region_of_origin')->getValue();

    switch ($curr_tid[0]['target_id']) {
      case "1808":
        $current_field_geolocation = $tid_1808_bruce_peninsula_lat_lng;
        break;
      case "1076":
        $current_field_geolocation = $tid_1076_central_greatlakes_lat_lng;
        break;
      case "1077":
        $current_field_geolocation = $tid_1077_eastern_greatlakes_lat_lng;
        break;
      case "1073":
        $current_field_geolocation = $tid_1073_north_eastern_noam_lat_lng;
        break;
      case "1829":
        $current_field_geolocation = $tid_1829_eastern_ontario_lat_lng;
        break;
      case "1058":
        $current_field_geolocation = $tid_1058_fingers_lakes_lat_lng;
        break;
      case "1074":
        $current_field_geolocation = $tid_1074_georgian_bay_lat_lng;
        break;
      case "1046":
        $current_field_geolocation = $tid_1046_great_lakes_lat_lng;
        break;
      case "1081":
        $current_field_geolocation = $tid_1081_hudsons_bay_lat_lng;
        break;
      case "1908":
        $current_field_geolocation = $tid_1908_lake_winnipeg_lat_lng;
        break;
      case "1817":
        $current_field_geolocation = $tid_1817_michigan_peninsula_lat_lng;
        break;
      case "1078":
        $current_field_geolocation = $tid_1078_north_great_lakes_lat_lng;
        break;
      case "1082":
        $current_field_geolocation = $tid_1082_ruperts_land_lat_lng;
        break;
      case "1079":
        $current_field_geolocation = $tid_1079_south_great_lakes_lat_lng;
        break;
      case "1080":
        $current_field_geolocation = $tid_1080_western_great_lake_lat_lng;
        break;
      case "1069":
        $current_field_geolocation = $tid_1069_western_ontario_lat_lng;
        break;
      case "1071":
        $current_field_geolocation = $tid_1071_other_lat_lng;
        break;
      case "1072":
        $current_field_geolocation = $tid_1072_unknown_lat_lng;
        break;
      default:

    }

    if($current_field_geolocation > 0) {
      $node->set('field_geolocation', $current_field_geolocation);
      $node->set('langcode', 'en');
      if ($node instanceof RevisionLogInterface) {
        $node->setRevisionLogMessage('Update geofield value in all nodes in center of region specific taxonomy.');
        $node->setRevisionUserId(\Drupal::currentUser()->id());
      }
      $node->save();
    }

    $sandbox['current']++;
  }

  $sandbox['#finished'] = min(($sandbox['current'] / $sandbox['total']), 1);
}


/**
 * Implements hook_cron().
 * an example for future use - note that it does not use batches (that is not best example)
 */
function change_update_fields_cron() {

 //// one node update Title example
//  $query = \Drupal::entityQuery('node')
//    ->condition('nid', '1');    // The ID of the node.
//  $nids = $query->execute();
//  $nodes = Node::loadMultiple($nids);
//  foreach ($nodes as $node) {
//    $node->set("title", strtoupper($node->title->value));
//    $node->save();
//  }
//  \Drupal::messenger()->addMessage('Nodes updated');
  //// end of update Title

//// start of cron job deleting table records when function is in an external file
//  \Drupal::moduleHandler()->loadInclude($module, $type, $name = NULL);
  \Drupal::moduleHandler()->loadInclude('change_update_fields', 'inc', 'delete_table_rows');
   delete_tracking_stats_rows();
}

/**
 * Implements hook_node_insert().
 * The only hook that knows new node->id() when is just created
 */
function change_update_fields_node_insert($node) {

  $the_new_nid = $node->id();
  $node->set("field_gks_reference_number", intval($the_new_nid));
  $node->save();
}

/**
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @return void
 */
function change_update_fields_entity_presave(Drupal\Core\Entity\EntityInterface $entity) {

//  $mt=$entity->getEntityType()->id();
//  $mt2=$entity->getEntityType()->getBundleEntityType();
//  $mt3=$entity->getEntityTypeId();

    if ($entity->bundle() == 'heritage_item') {
      $field_gks_value = $entity->get('field_gks_reference_number')->value;
      if ($field_gks_value == '1' OR $field_gks_value == '') {
        $entity->set('field_gks_reference_number', intval($entity->id()));
      }
    }
}

///**
// * Implements hook_form_alter().
// * does not work in same module with hook_node_insert()
// */
//function change_update_fields_form_node_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
//
//  $stop=1;
//  if ($form_id == 'node_heritage_item_edit_form') {
//    // Retrieving unprocessed field value.
//    $original_value = $form['field_gks_reference_number']['widget'][0]['value']['#default_value'];
//    $node_nid = intval($form_state->getformObject()->getEntity()->id());
//    if ($original_value) {
//      $form['field_gks_reference_number']['widget'][0]['value']['#default_value'] = $node_nid;
//    }
//    $stop=1;
//  }
//}



//// outdated ver for D8 below. In D9 we use annotation and services.yml to create drush custom-commands
//// see: https://www.specbee.com/blogs/writing-your-own-custom-drush-9-and-10-commands

///**
// * Implements hook_drush_command().
// */
//function change_update_fields_drush_command() {
//  return array(
//    'delete-tracking-stats-rows' => array(
//      'description' => dts('Remove rows from search_api_tracking_stats table.'),
//      'alias' => array('dts'),
//    ),
//  );
//}
//
//
//
///**
// * Process search_api_tracking_stats table.
// * Drush command logic.
// * drush_[MODULE_NAME]_[COMMAND_NAME]().
// */
//function drush_change_update_fields_delete_tracking_stats_rows() {
//  \Drupal::moduleHandler()->loadInclude('change_update_fields', 'inc', 'delete_table_rows');
//  delete_tracking_stats_rows();
//}


